#include "../incl/maze.hpp"
#include <ranges>
#include <algorithm>
#include <random>

Maze::Maze(
	int 		num_rows,
	int 		num_cols,
	Position 	start_pos, 
	Position 	goal_pos,
	bool		debug,
	float		blocked_proportion
	):
	num_rows 	{num_rows}, 
	num_cols 	{num_cols},
	start 		{Cell(start_pos, Contents::START)},
	goal  		{Cell(goal_pos, Contents::GOAL)} {

	std::vector<Cell> options;

	for (int row: std::views::iota(0, int(num_rows))){
		for (int col: std::views::iota(0, int(num_cols))){

			bool is_start = (row == start_pos.row && col == start_pos.col);
			bool is_end	  = (row == goal_pos.row  && col == goal_pos.col);
			
			//if 		(is_start) 	{grid[row][col] = start;} 
			//else if (is_end) 	{grid[row][col] = goal;} 
			//else{
			//	Cell new_cell 	= Cell(Position(row,col),Contents::EMPTY); 
			//	options.push_back(new_cell);
			//	grid[row][col] = new_cell;
			//}

		}
	}
}

std::string Maze::toString(){
	std::string maze_str = "";
	for (std::vector<Cell> row: grid){
		maze_str.append("a");
	}
	return maze_str;
}
//
//			// Non-deterministic random device
//			std::random_device 	rd;
//			// Merssene Twister from algorithm library. Feed the 
//			// non-deterministic device as parameter.
//			std::mt19937 		rng(rd());	
//			// Shuffle options
//			std::shuffle(std::begin(options), std::end(options), rng);
//
//			int number_blocked = round((num_cols * num_cols) * blocked_proportion);
//
//			// Create a view (iterator) from first number_blocked elements 
//			// from options and pass to loop.
//			for (Cell cell: options | std::views::take(number_blocked)){
//				cell.markAsBlocked();	
//			}
//		}
//

